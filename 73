#include <stdio.h>
    }

    // 2. Allocate memory
    Allocation = allocate_matrix(P, R);
    Max = allocate_matrix(P, R);
    Need = allocate_matrix(P, R);
    Available = (int*)malloc(R * sizeof(int));

    // 3. Read Allocation and Max matrices
    read_matrix(Allocation, "Allocation");
    read_matrix(Max, "Max");

    // 4. Read Available vector
    printf("Enter Available vector:\n");
    for (int i = 0; i < R; i++) {
        if (scanf("%d", &Available[i]) != 1) {
            fprintf(stderr, "Error reading Available vector element %d\n", i);
            return 1;
        }
    }

    // 5. Compute Need matrix
    compute_need();

    // 6. Check for safety
    int *safe_sequence = (int*)malloc(P * sizeof(int));
    int *deadlocked_processes = (int*)malloc(P * sizeof(int));

    // Initialize deadlocked_processes with a sentinel value (-1) for reliable printing
    for (int i = 0; i < P; i++) {
        deadlocked_processes[i] = -1;
    }

    if (is_safe(safe_sequence, deadlocked_processes)) {
        printf("No deadlock\n");
        // FIX for Safe sequence formatting: No space after colon
        printf("Safe sequence: P%d", safe_sequence[0]);
        for (int i = 1; i < P; i++) {
            printf(" P%d", safe_sequence[i]);
        }
        printf(" \n");
    } else {
        printf("Deadlock:"); // FIX for Deadlock formatting: No space after colon
        
        // Print all collected deadlocked processes, stopping at the sentinel value
        for (int i = 0; i < P; i++) {
            if (deadlocked_processes[i] != -1) {
                // Print all PIDs with a leading space
                printf(" P%d", deadlocked_processes[i]);
            } else {
                break; // Stop when the sentinel value is encountered
            }
        }
        printf(" \n");
    }

    // 7. Free memory
    free(Available);
    free(safe_sequence);
    free(deadlocked_processes);
    free_matrix(Allocation, P);
    free_matrix(Max, P);
    free_matrix(Need, P);

    return 0;
}
