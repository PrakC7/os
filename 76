#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAX_PAGES 100 // Define a maximum size for the reference string

// Function to find the optimal page to replace
// It returns the index of the frame containing the page that will not be used 
// for the longest time in the future.
int find_optimal_page(const int frames_array[], int frames, const int pages[], int n, int current_index) {
    int max_future_index = -1; // Index in the 'frames_array' to replace
    int max_distance = -1;     // Longest distance to next use

    for (int j = 0; j < frames; j++) {
        int page_id = frames_array[j];
        int distance = INT_MAX; // Initialize distance to infinity (means page is never used again)

        // Search the rest of the reference string for the next use of this page
        for (int k = current_index + 1; k < n; k++) {
            if (pages[k] == page_id) {
                distance = k; // Found next use at index k
                break;
            }
        }

        // If a page is never used again (distance remains INT_MAX), it's the best choice.
        // If distance is not INT_MAX, we check if it's the farthest one we've seen so far.
        if (distance == INT_MAX) {
            return j; // Found a page that will never be used again: immediately return its frame index
        }
        
        // Use the index k (the future index) as the distance metric
        if (distance > max_distance) {
            max_distance = distance;
            max_future_index = j;
        }
    return max_future_index;
            if (frames_array[j] == incoming_page) {
                page_found = 1;
                break;
            }
        }

        if (page_found) {
            // HIT: No action needed for Optimal
            continue;
        } else {
            // 2. Page FAULT
            page_faults++;

            // 3. Find an empty frame
            int empty_frame_index = -1;
            for (int j = 0; j < frames; j++) {
                if (frames_array[j] == -1) {
                    empty_frame_index = j;
                    break;
                }
            }

            // 4. Perform replacement
            int frame_to_replace;
            if (empty_frame_index != -1) {
                // Case A: Empty frame available
                frame_to_replace = empty_frame_index;
            } else {
                // Case B: Frames full, find the optimal page to replace
                frame_to_replace = find_optimal_page(frames_array, frames, pages, n, i);
            }

            // Load the new page into the chosen frame
            frames_array[frame_to_replace] = incoming_page;
        }
    }

    free(frames_array);
    return page_faults;
}

int main() {
    int n; // number of pages in the reference string
    int frames; // number of available frames
    int pages[MAX_PAGES];
    
    // Input for number of pages
    printf("Enter number of pages: ");
    if (scanf("%d", &n) != 1 || n <= 0 || n > MAX_PAGES) {
        fprintf(stderr, "Invalid input for number of pages.\n");
        return 1;
    }
    
    // Input for the page reference string
    printf("Enter the page reference string: ");
    for (int i = 0; i < n; i++) {
        if (scanf("%d", &pages[i]) != 1) {
            fprintf(stderr, "Invalid input while reading page reference string.\n");
            return 1;
        }
    }
    
    // Input for number of frames
    printf("Enter number of frames: ");
    if (scanf("%d", &frames) != 1 || frames <= 0) {
        fprintf(stderr, "Invalid input for number of frames.\n");
        return 1;
    }

    // Simulate Optimal
    int total_faults = simulate_optimal(pages, n, frames);

    // Output the result
    printf("Total Page Faults = %d\n", total_faults);

    return 0;
}

