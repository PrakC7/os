#include <stdio.h>
    
    // 2b. Service requests to the LEFT (in reverse sorted order: from DISK_MIN up to the head)
    // Requests left of head are sorted ascending, so we traverse them normally here (0 to initial_head)
    for (int i = 0; i < left_count; i++) {
        int next_request = requests_left_of_head[i];
        total_seek_operations += abs(next_request - current_head);
        current_head = next_request;
        printf(" -> %d", current_head);
    }
    
    printf("\n");
    
    // Output Total Seek Operations
    printf("Total Seek Operations: %ld\n", total_seek_operations);
}

int main() {
    int n;
    int requests[MAX_REQUESTS];
    int initial_head;
    int disk_max;

    // Input 1: Number of disk requests
    printf("Enter number of disk requests: ");
    if (scanf("%d", &n) != 1 || n <= 0 || n > MAX_REQUESTS) {
        fprintf(stderr, "Invalid input for number of requests.\n");
        return 1;
    }
    
    // Input 2: Disk requests
    printf("Enter the disk requests (space separated): ");
    for (int i = 0; i < n; i++) {
        if (scanf("%d", &requests[i]) != 1) {
            fprintf(stderr, "Invalid input for disk request %d.\n", i + 1);
            return 1;
        }
    }
    
    // Input 3: Initial head position
    printf("Enter initial head position: ");
    if (scanf("%d", &initial_head) != 1) {
        fprintf(stderr, "Invalid input for initial head position.\n");
        return 1;
    }
    
    // Input 4: Disk size (max cylinder number)
    printf("Enter disk size (max cylinder number): ");
    if (scanf("%d", &disk_max) != 1 || disk_max <= 0) {
        fprintf(stderr, "Invalid input for disk size.\n");
        return 1;
    }

    // Input validation (requests must be within disk limits)
    for (int i = 0; i < n; i++) {
        if (requests[i] < DISK_MIN || requests[i] > disk_max) {
             fprintf(stderr, "Disk request %d is outside the range [0, %d].\n", requests[i], disk_max);
             return 1;
        }
    }
    if (initial_head < DISK_MIN || initial_head > disk_max) {
        fprintf(stderr, "Initial head position is outside the range [0, %d].\n", disk_max);
        return 1;
    }

    // The SCAN simulation is run assuming the initial direction is RIGHT (towards DISK_MAX).
    simulate_scan(requests, n, initial_head, disk_max);

    return 0;
}
